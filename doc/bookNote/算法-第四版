1 集合Collection。在java中，集合继承了Iterable，所以集合都是可以迭代的。迭代是一个重要的模式，很多语言中都是一级特性。java中基本上所有的集合类都继承自集合。要记着Map不是，Map是单独的Interface，不可迭代。在java中Map替代了Dictionary，是键置对的映射，不是图。Map提供了三种collection view，即key的集合，value的集合以及key-value的集合。
2 先进先出队列，简称队列。是一种基于先进先出模式的集合。
3 下压栈，简称栈。是一种基于后进先出模式的集合。在进行表达式运算时，使用两个栈可以方便的解析表达式。
--定容栈。使用数组实现。主要实现：一个数组，一个int表示数组内元素个数，push方法：在队尾增加元素，pop方法在队尾取出元素。在java中Stack的实现是继承了Vector--vector是使用数组实现的，内部方法都是同步的
--使用数组实现会有一个问题：java中数组一旦创建其大小是无法改变的。处理方式是resize方法，就是将所有元素都拷贝到一个新的数组中。Arrays.copyOf
--对象游离。在实现pop方法时，记得将pop出的对象使用null替代，使得数组中不再包含这个删除对象的引用，这样java的虚拟机可以进行垃圾回收。在java的实现中也有该种操作。
--迭代器。Collection类都会实现Iterable接口，其中一个方法iterator，会返回一个Iterator对象。这个对象有hasNext和next两个方法。可以用于遍历集合元素。java中不同的集合类都有不同的迭代器的实现。
4 链表。链表是一种递归的数据结构。它或者为null，或者指向另一个结点的引用。结点含有一个元素和指向另一个结点的引用。
--结点。嵌套定义：
class Node {
  Item item;
  Node next;
}
链表有一系列的Node构成，同时每一个node也都是一个链表。java中的LinkedList是一个双向循环链表
--下压栈也可以使用链表进行实现。不过我在java中没看到使用链表实现的栈
--链表是数组的一种重要替代方式，
5 数组和链表是两种基本的表示对象集合的方式。java内置了数组，链表也可以很容易实现。
6 程序的时空复杂度。
--使用System.currentTimeMillis打印当前时间去计算程序执行时间。
--同一程序在不同计算机上的执行时间不同，猜想：不同机器上同一程序运行时间之比是一个常数。
--问题规模N与执行时间T大概是 T=aN^3，大概成正比。
--影响程序执行时间的情况可能很复杂，不过主要取决于两点：1 执行每条语句的耗时 2 执行每条语句的频率。前者取决于计算机、java编译器等。后者取决于程序本身的输入。
--判断语句的执行频率。一个关键的现象，执行最频繁的指令决定了程序执行的总时间，这些指令被成为程序的内循环
--实现算法中几种结构性原语（普通语句，条件语句，循环，嵌套和方法调用），其成本增长一般都是问题规模N的若干函数之一：
常数级别：1 普通语句
对数级别：logN 二分策略，如二分查找
线性级别：N 循环
线性对数级别：NlogN 分治，如归并排序，快速排序
平方级别：N^2 双层循环
立方级别：N^3 三层循环
指数级别：2^N 穷举查找
使用更快的算法，对于双层循环，可以通过先排序再进行二分查找，降低成本增长。
7 内存的使用
内存使用的分析比时间要简单。分析时可以将复杂对象转换为原始数据类型，而原始类型时事先定义好的。只需要将变量个数与类型对应字节数相加即可。
--对象的内存：将对象所有实例变量与对象本身的开销（一般是16字节，包括对象引用，垃圾回收信息，同步信息等）相加即可。另外一般内存的使用都会被填充为8字节的倍数，64位机器字的倍数。譬如，Integer对象占用24字节，16字节对象+4个字节的int值+4个字节的填充。一个对象的引用是8个字节，是一个内存地址。
对于非静态内部类，还需要额外的8个字节指向外部对象的引用。
--数组：java中数组被实现为对象，一般会因为记录长度而需要额外的内存，一个原始类型数组一般需要24个字节头信息（16字节对象信息，4个字节记录长度，4个字节填充。），再加上保存值所需要的内存
--字符串对象： 每个String对象会占用40个字节--一个指向字符数组的引用（8个字节），和三个int值，再加对象本身开销16字节
8 动态连通性问题：
简单描述：给出一系列的点，点之间可以使用线连接，连接满足自反性，对称性，传递性。如何判断其中两个点是否连接？
skip...

排序


